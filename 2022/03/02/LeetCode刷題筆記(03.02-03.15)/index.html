<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>LeetCode刷題筆記(03.02-03.15) | 零泽</title><meta name="keywords" content="算法,LeetCode"><meta name="author" content="零泽"><meta name="copyright" content="零泽"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="今後的刷題筆記都不再單獨放置了，全部放在一起，節省空間 每道題後標註的日期均爲上傳日期，不是完成日期 ps:文件太大了，格式化很麻烦，所以还是分开吧 Easy[202] 快乐数hash-table | math 2022&#x2F;03&#x2F;02 class Solution &amp;#123; public:  bool isHappy(int n) &amp;#123;    if (n &#x3D;&#x3D; 1) &amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode刷題筆記(03.02-03.15)">
<meta property="og:url" content="https://lz37.github.io/2022/03/02/LeetCode%E5%88%B7%E9%A1%8C%E7%AD%86%E8%A8%98(03.02-03.15)/index.html">
<meta property="og:site_name" content="零泽">
<meta property="og:description" content="今後的刷題筆記都不再單獨放置了，全部放在一起，節省空間 每道題後標註的日期均爲上傳日期，不是完成日期 ps:文件太大了，格式化很麻烦，所以还是分开吧 Easy[202] 快乐数hash-table | math 2022&#x2F;03&#x2F;02 class Solution &amp;#123; public:  bool isHappy(int n) &amp;#123;    if (n &#x3D;&#x3D; 1) &amp;#123;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/lz37/images/img/29535589_84295672_p0_Archive%20%20%E9%87%8C%E4%B8%AA%E4%BA%BA%E5%AD%98%E6%A1%A3%E5%A4%84_%E8%BE%89%E7%8F%96%E7%AA%81%E5%9B%B4.jpg">
<meta property="article:published_time" content="2022-03-02T08:34:00.000Z">
<meta property="article:modified_time" content="2021-03-15T03:08:00.000Z">
<meta property="article:author" content="零泽">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/lz37/images/img/29535589_84295672_p0_Archive%20%20%E9%87%8C%E4%B8%AA%E4%BA%BA%E5%AD%98%E6%A1%A3%E5%A4%84_%E8%BE%89%E7%8F%96%E7%AA%81%E5%9B%B4.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lz37.github.io/2022/03/02/LeetCode%E5%88%B7%E9%A1%8C%E7%AD%86%E8%A8%98(03.02-03.15)/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-03-15 11:08:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/24218478_84738252_p0_%EF%BF%A6ANKE_the_moon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/lz37/images/img/29535589_84295672_p0_Archive%20%20%E9%87%8C%E4%B8%AA%E4%BA%BA%E5%AD%98%E6%A1%A3%E5%A4%84_%E8%BE%89%E7%8F%96%E7%AA%81%E5%9B%B4.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">零泽</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">LeetCode刷題筆記(03.02-03.15)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-02T08:34:00.000Z" title="发表于 2022-03-02 16:34:00">2022-03-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-03-15T03:08:00.000Z" title="更新于 2021-03-15 11:08:00">2021-03-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="LeetCode刷題筆記(03.02-03.15)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>今後的刷題筆記都不再單獨放置了，全部放在一起，節省空間</p>
<p>每道題後標註的日期均爲上傳日期，不是完成日期</p>
<p>ps:文件太大了，格式化很麻烦，所以还是分开吧</p>
<h1 id="Easy"><a href="#Easy" class="headerlink" title="Easy"></a>Easy</h1><h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="[202] 快乐数"></a>[202] 快乐数</h2><p><strong>hash-table | math</strong></p>
<p>2022/03/02</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span> &amp;&amp; n &lt;= <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">      num += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">      n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isHappy</span>(num);</span><br><span class="line">    <span class="comment">// 402/402 cases passed (0 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 100 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 94.2 % of cpp submissions (5.7 MB)</span></span><br><span class="line">    <span class="comment">//主体部分是很简单的，只是要注意如果输入的正整数在某个递归之后小于等于4并且大于1，那么他就不是快乐数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="[94] 二叉树的中序遍历"></a>[94] 二叉树的中序遍历</h2><p><strong>hash-table | stack | tree</strong></p>
<p>2022/03/07</p>
<p>关于迭代：迭代法也称辗转法，是一种不断用变量的旧值递推新值的过程</p>
<p>关于 STL - emplace 与 push 的区别：</p>
<p>设置数据结构 data</p>
<pre><code>//假设栈内的数据类型是data
class data &#123;
  int a;
  int b;
public:
  data(int x, int y):a(x), b(y) &#123;&#125;
&#125;;
</code></pre><ol>
<li><p>push 的操作可以直接用于 emplace</p>
<pre><code>//push
data d(1,2);
S.push(d) 或 S.emplace(d);
</code></pre></li>
<li><p>在传入时候构造对象</p>
<pre><code>S.push(data(1,2));
S.emplace(data(1,2));
</code></pre></li>
<li><p><strong>emplace 可以直接传入构造对象需要的元素，然后自己调用其构造函数！</strong></p>
<pre><code>S.emplace(1,2)
</code></pre></li>
</ol>
<p>意思是，emplace 这样接受新对象的时候，自己会调用其构造函数生成对象然后放在容器内（比如这里传入了 1，2，它则会自动调用一次 data(1,2))</p>
<p>而 push，只能让其构造函数构造好了对象之后，再使用复制构造函数！</p>
<p>相当于 emplace 直接把原料拿进家，造了一个。而 push 是造好了之后，再复制到自己家里，多了复制这一步。</p>
<p>所以 emplace 相对于 push，使用第三种方法会更节省内存。</p>
<p><strong>注意</strong>：</p>
<pre><code>emplace_back(type) 对应 push_back(type)
emplace(i, type) 对应于 insert(type, i)
emplace_front(type) 对应于 push_front()
</code></pre><p><strong>但是</strong>！对于 stack 和 queue，只有 push 操作，所以也只有 emplace 操作，此时它们是相对应的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span></span><br><span class="line"><span class="comment"> * right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* if (!root) return &#123;&#125;;</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; left, right;</span></span><br><span class="line"><span class="comment">    left = inorderTraversal(root-&gt;left);</span></span><br><span class="line"><span class="comment">    right = inorderTraversal(root-&gt;right);</span></span><br><span class="line"><span class="comment">    left.push_back(root-&gt;val);</span></span><br><span class="line"><span class="comment">    left.insert(left.end(), right.begin(), right.end());</span></span><br><span class="line"><span class="comment">    return left;</span></span><br><span class="line"><span class="comment">    // 70/70 cases passed (0 ms)</span></span><br><span class="line"><span class="comment">    // Your runtime beats 100 % of cpp submissions</span></span><br><span class="line"><span class="comment">    // Your memory usage beats 7.08 % of cpp submissions (9.2 MB)</span></span><br><span class="line"><span class="comment">    //*递归算法，可以看到用了许多栈空间 */</span></span><br><span class="line">    stack&lt;TreeNode *&gt; treeNodeStack;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">while</span> (root || !treeNodeStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">while</span> (root) &#123;</span><br><span class="line">        treeNodeStack.<span class="built_in">push</span>(root);</span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">auto</span> node = treeNodeStack.<span class="built_in">top</span>();</span><br><span class="line">      treeNodeStack.<span class="built_in">pop</span>();</span><br><span class="line">      ans.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">      root = node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="comment">// 70/70 cases passed (0 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 100 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 36.4 % of cpp submissions (8.2 MB)</span></span><br><span class="line">    <span class="comment">//*迭代算法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="[101] 对称二叉树"></a>[101] 对称二叉树</h2><p><strong>tree | depth-first-search | breadth-first-search</strong></p>
<p>2022/03/08</p>
<p>利用深搜解决</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span></span><br><span class="line"><span class="comment"> * right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">function</span><span class="params">(TreeNode *leftRoot, TreeNode *rightRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rightRoot &amp;&amp; leftRoot) &#123;</span><br><span class="line">      <span class="keyword">if</span> (rightRoot-&gt;val != leftRoot-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">function</span>(leftRoot-&gt;left, rightRoot-&gt;right) &amp;&amp;</span><br><span class="line">               <span class="built_in">function</span>(leftRoot-&gt;right, rightRoot-&gt;left);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightRoot || leftRoot) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">function</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    <span class="comment">// 197/197 cases passed (0 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 100 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 48.8 % of cpp submissions (16 MB)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="[104] 二叉树的最大深度"></a>[104] 二叉树的最大深度</h2><p><strong>tree | depth-first-search</strong></p>
<p>2022/03/08</p>
<p>超级无敌螺旋托马斯火箭简单的递归</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span></span><br><span class="line"><span class="comment"> * right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> maxDeep = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">findMaxDeep</span><span class="params">(TreeNode *root, <span class="type">int</span> deep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">      maxDeep = <span class="built_in">max</span>(maxDeep, deep);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">findMaxDeep</span>(root-&gt;left, deep + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">findMaxDeep</span>(root-&gt;right, deep + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">findMaxDeep</span>(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> maxDeep;</span><br><span class="line">    <span class="comment">// 39/39 cases passed (4 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 91.71 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 93.72 % of cpp submissions (18.3 MB)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="[160] 相交链表"></a>[160] 相交链表</h2><p><strong>linked-list</strong></p>
<p>2022/03/13</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    vector&lt;ListNode *&gt; listA, listB;</span><br><span class="line">    <span class="keyword">while</span> (headA) &#123;</span><br><span class="line">      listA.<span class="built_in">emplace_back</span>(headA);</span><br><span class="line">      headA = headA-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (headB) &#123;</span><br><span class="line">      listB.<span class="built_in">emplace_back</span>(headB);</span><br><span class="line">      headB = headB-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> posA = listA.<span class="built_in">size</span>() - <span class="number">1</span>, posB = listB.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; posA &gt;= <span class="number">0</span> &amp;&amp; posB &gt;= <span class="number">0</span>; posA--, posB--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (listA[posA] != listB[posB]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> posA &gt;= <span class="number">0</span> ? listA[posA]-&gt;next : listA[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 39/39 cases passed (28 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 99.64 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 20.93 % of cpp submissions (16.4 MB)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="[169] 多数元素"></a>[169] 多数元素</h2><p><strong>array | divide-and-conquer | bit-manipulation</strong></p>
<p>2022/03/14</p>
<p><strong>摩尔投票法</strong>：</p>
<p>核心就是对拼消耗。</p>
<p>玩一个诸侯争霸的游戏，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利。</p>
<p>那就大混战呗，最差所有人都联合起来对付你（对应你每次选择作为计数器的数都是众数），或者其他国家也会相互攻击（会选择其他数作为计数器的数），但是只要你们不要内斗，最后肯定你赢。</p>
<p>最后能剩下的必定是自己人。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数(当下的数)开始计数，总能找到最多的那个</span></span><br><span class="line">    <span class="type">int</span> ans, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        ans = nums[i];</span><br><span class="line">        count++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        count += nums[i] == ans ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="comment">// 43/43 cases passed (12 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 91.53 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 74.89 % of cpp submissions (19.1 MB)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h1><h2 id="201-数字范围按位与"><a href="#201-数字范围按位与" class="headerlink" title="[201] 数字范围按位与"></a>[201] 数字范围按位与</h2><p><strong>bit-manipulation</strong></p>
<p>2022/03/02</p>
<p>_解法看註釋就行了，挺無語的_</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//*当一个数+1时，总会有这么一个规律“某一位后的数字，全部被置为相反数”</span></span><br><span class="line">    <span class="comment">//*即前缀一样</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      left &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">      right &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left &lt;&lt; i;</span><br><span class="line">    <span class="comment">// 8268/8268 cases passed (4 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 92.23 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 90.58 % of cpp submissions (5.7 MB)</span></span><br><span class="line">    <span class="comment">/* if (left == right) return left;</span></span><br><span class="line"><span class="comment">    int capturer = 0b01000000000000000000000000000000;</span></span><br><span class="line"><span class="comment">    int ans = 0b01111111111111111111111111111111;</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; 31; i++) &#123;</span></span><br><span class="line"><span class="comment">      for (int j = left; j &lt;= right; j++) &#123;</span></span><br><span class="line"><span class="comment">        if (j &lt; 0) break;</span></span><br><span class="line"><span class="comment">        if (!(int)(j &amp; capturer)) &#123;</span></span><br><span class="line"><span class="comment">          ans ^= capturer;</span></span><br><span class="line"><span class="comment">          break;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      capturer &gt;&gt;= 1;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return ans;</span></span><br><span class="line"><span class="comment">    //! Time Limit Exceeded */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="384-打乱数组"><a href="#384-打乱数组" class="headerlink" title="[384] 打乱数组"></a>[384] 打乱数组</h2><p><strong>Unknown</strong>(_不是我標錯 tag 了，那上面就是這個_)</p>
<p>2022/03/02</p>
<p>無語子，與其說是考驗算法，不如說是考驗隨機函數的用法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; sample;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Solution</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123; sample = nums; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reset</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sample; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp = sample;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="type">int</span> length = tmp.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = length; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="type">int</span> index = <span class="built_in">rand</span>() % i;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(tmp[index]);</span><br><span class="line">      tmp.<span class="built_in">erase</span>(tmp.<span class="built_in">begin</span>() + index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 10/10 cases passed (112 ms)</span></span><br><span class="line">  <span class="comment">// Your runtime beats 37.14 % of cpp submissions</span></span><br><span class="line">  <span class="comment">// Your memory usage beats 12.87 % of cpp submissions (92.3 MB)</span></span><br><span class="line">  <span class="comment">//第一次见这种题，网上找了个参考：https://blog.csdn.net/qq_19841133/article/details/88907051</span></span><br><span class="line">  <span class="comment">//真没想到算法题还有这样的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_1 = obj-&gt;reset();</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj-&gt;shuffle();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="[31] 下一个排列"></a>[31] 下一个排列</h2><p><strong>array</strong></p>
<p>2022/03/03</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="type">int</span> minPos = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">          minPos = nums[j] &lt; nums[minPos] &amp;&amp; nums[j] &gt; nums[i] ? j : minPos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[minPos]);</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>() + i + <span class="number">1</span>, nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 265/265 cases passed (4 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 73.64 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 90.64 % of cpp submissions (11.6 MB)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="[48] 旋转图像"></a>[48] 旋转图像</h2><p><strong>array</strong></p>
<p>2022/03/04</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(matrix[j][i], matrix[j][n - <span class="number">1</span> - i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 21/21 cases passed (0 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 100 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 36.98 % of cpp submissions (6.9 MB)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如下，非常简单</span></span><br><span class="line"><span class="comment">    123</span></span><br><span class="line"><span class="comment">    456</span></span><br><span class="line"><span class="comment">    789</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    147</span></span><br><span class="line"><span class="comment">    258</span></span><br><span class="line"><span class="comment">    369</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    741</span></span><br><span class="line"><span class="comment">    852</span></span><br><span class="line"><span class="comment">    963</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="[49] 字母异位词分组"></a>[49] 字母异位词分组</h2><p><strong>hash-table | string</strong></p>
<p>2022/03/04</p>
<p><strong>存数字 double 是最大的！</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getNum</span><span class="params">(<span class="type">char</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">23</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;j&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">29</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">31</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">37</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">41</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">43</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">47</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">53</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">59</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">61</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">67</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">71</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">73</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">79</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">83</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">89</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">97</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">101</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">    map&lt;<span class="type">double</span>, vector&lt;string&gt;&gt; hashmap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : strs) &#123;</span><br><span class="line">      <span class="type">double</span> hashTmp = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> chars : i) &#123;</span><br><span class="line">        hashTmp *= <span class="built_in">getNum</span>(chars);</span><br><span class="line">      &#125;</span><br><span class="line">      hashmap[hashTmp].<span class="built_in">push_back</span>(i);  <span class="comment">//没有的话自动帮创一个key</span></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; i : hashmap) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(i.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="comment">// 115/115 cases passed (24 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 93.4 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 89.56 % of cpp submissions (18.6 MB)</span></span><br><span class="line">    <span class="comment">//*double都比unsigned long long存得大，我服了</span></span><br><span class="line">    <span class="comment">/* vector&lt;vector&lt;int&gt;&gt; hash;</span></span><br><span class="line"><span class="comment">    vector&lt;vector&lt;string&gt;&gt; ans;</span></span><br><span class="line"><span class="comment">    for (auto i : strs) &#123;</span></span><br><span class="line"><span class="comment">      vector&lt;int&gt; hashTmp(26, 0);</span></span><br><span class="line"><span class="comment">      for (auto chars : i) &#123;</span></span><br><span class="line"><span class="comment">        hashTmp[chars - &#x27;a&#x27;]++;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      bool flag = 1;</span></span><br><span class="line"><span class="comment">      for (int j = 0; j &lt; hash.size(); j++) &#123;</span></span><br><span class="line"><span class="comment">        if (hashTmp == hash[j]) &#123;</span></span><br><span class="line"><span class="comment">          flag = 0;</span></span><br><span class="line"><span class="comment">          ans[j].push_back(i);</span></span><br><span class="line"><span class="comment">          break;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      if (flag) &#123;</span></span><br><span class="line"><span class="comment">        hash.push_back(hashTmp);</span></span><br><span class="line"><span class="comment">        ans.push_back(vector&lt;string&gt;(1, i));</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return ans;</span></span><br><span class="line"><span class="comment">    //超时 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="[56] 合并区间"></a>[56] 合并区间</h2><p><strong>array | sort</strong></p>
<p>2022/03/04</p>
<p>双指针解法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">start</span><span class="params">(intervals.size())</span>, <span class="title">end</span><span class="params">(intervals.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      start[i] = intervals[i][<span class="number">0</span>];</span><br><span class="line">      end[i] = intervals[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(start.<span class="built_in">begin</span>(), start.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(end.<span class="built_in">begin</span>(), end.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == intervals.<span class="built_in">size</span>() - <span class="number">1</span> || start[i + <span class="number">1</span>] &gt; end[i]) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;start[j], end[i]&#125;);</span><br><span class="line">        j = i + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="comment">// 169/169 cases passed (24 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 77.18 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 19.97 % of cpp submissions (18.7 MB)</span></span><br><span class="line">    <span class="comment">//*双指针，注意执行时候的条件</span></span><br><span class="line">    <span class="comment">/* sort(intervals.begin(), intervals.end(),</span></span><br><span class="line"><span class="comment">         [](vector&lt;int&gt; a, vector&lt;int&gt; b) &#123; return a[0] &lt; b[0]; &#125;);</span></span><br><span class="line"><span class="comment">    for (int i = 1; i &lt; intervals.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">      if (intervals[i][0] &lt;= intervals[i - 1][1]) &#123;</span></span><br><span class="line"><span class="comment">        intervals[i - 1][1] = max(intervals[i][1], intervals[i - 1][1]);</span></span><br><span class="line"><span class="comment">        intervals.erase(intervals.begin() + i--);</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return intervals;</span></span><br><span class="line"><span class="comment">    //超时 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="[64] 最小路径和"></a>[64] 最小路径和</h2><p><strong>array | dynamic-programming</strong></p>
<p>2022/03/05</p>
<p>很简单的动规</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(grid.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(grid[<span class="number">0</span>].<span class="built_in">size</span>()));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; grid.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; grid.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp.<span class="built_in">back</span>().<span class="built_in">back</span>();</span><br><span class="line">    <span class="comment">// 61/61 cases passed (8 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 77.09 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 49.79 % of cpp submissions (9.8 MB)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="[75] 颜色分类"></a>[75] 颜色分类</h2><p><strong>array | two-pointers | sort</strong></p>
<p>2022/03/05</p>
<p>题目不让用库函数里的 sort，那么就只好自己手撕了，应用到了双指针和分治的思想</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">      <span class="type">int</span> left = begin;</span><br><span class="line">      <span class="type">int</span> right = end;</span><br><span class="line">      <span class="type">int</span> key = nums[right];</span><br><span class="line">      <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= key) &#123;</span><br><span class="line">          left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">          nums[right] = nums[left];</span><br><span class="line">          right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] &gt;= key) &#123;</span><br><span class="line">          right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">          nums[left] = nums[right];</span><br><span class="line">          left++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      nums[right] = key;</span><br><span class="line">      <span class="built_in">qsort</span>(nums, begin, right - <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">qsort</span>(nums, right + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123; <span class="built_in">qsort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>); &#125;</span><br><span class="line">  <span class="comment">// 87/87 cases passed (4 ms)</span></span><br><span class="line">  <span class="comment">// Your runtime beats 39.75 % of cpp submissions</span></span><br><span class="line">  <span class="comment">// Your memory usage beats 96.08 % of cpp submissions (7.9 MB)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="[96] 不同的二叉搜索树"></a>[96] 不同的二叉搜索树</h2><p><strong>dynamic-programming | tree</strong></p>
<p>2022/03/07</p>
<p>关于二叉查找树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树</p>
<p>很简单的题目，可以放到 easy 里面了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        dp[i] += (dp[i - j] * dp[j - <span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    <span class="comment">// 19/19 cases passed (0 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 100 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 80.9 % of cpp submissions (5.8 MB)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="[98] 验证二叉搜索树"></a>[98] 验证二叉搜索树</h2><p><strong>tree | depth-first-search</strong></p>
<p>2022/03/07</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span></span><br><span class="line"><span class="comment"> * right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">left</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">left</span>(root-&gt;left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">right</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;right) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">right</span>(root-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">      <span class="keyword">if</span> (root-&gt;val &lt;= <span class="built_in">right</span>(root-&gt;left)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        ans = ans &amp;&amp; <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">      <span class="keyword">if</span> (root-&gt;val &gt;= <span class="built_in">left</span>(root-&gt;right)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        ans = ans &amp;&amp; <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="comment">// 80/80 cases passed (12 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 51.29 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 99.41 % of cpp submissions (20.9 MB)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="[102] 二叉树的层序遍历"></a>[102] 二叉树的层序遍历</h2><p><strong>tree | breadth-first-search</strong></p>
<p>2022/03/08</p>
<p>很简单的广搜</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span></span><br><span class="line"><span class="comment"> * right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode *root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    deque&lt;TreeNode *&gt; bfs;</span><br><span class="line">    bfs.<span class="built_in">emplace_back</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!bfs.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      ans.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="type">int</span> length = bfs.<span class="built_in">size</span>();</span><br><span class="line">      <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = bfs.<span class="built_in">front</span>();</span><br><span class="line">        bfs.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;left) bfs.<span class="built_in">emplace_back</span>(tmp-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;right) bfs.<span class="built_in">emplace_back</span>(tmp-&gt;right);</span><br><span class="line">        ans.<span class="built_in">back</span>().<span class="built_in">emplace_back</span>(tmp-&gt;val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="comment">// 34/34 cases passed (0 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 100 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 37.24 % of cpp submissions (12.3 MB)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="[105] 从前序与中序遍历序列构造二叉树"></a>[105] 从前序与中序遍历序列构造二叉树</h2><p><strong>array | tree | depth-first-search</strong></p>
<p>2022/03/09</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span></span><br><span class="line"><span class="comment"> * right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function">TreeNode *<span class="title">function</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder, vector&lt;<span class="type">int</span>&gt; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> rootPos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; rootPos &lt; inorder.<span class="built_in">size</span>(); rootPos++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (inorder[rootPos] == preorder[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[<span class="number">0</span>]);</span><br><span class="line">    root-&gt;left = <span class="built_in">function</span>(</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(preorder.<span class="built_in">begin</span>() + <span class="number">1</span>, preorder.<span class="built_in">begin</span>() + rootPos + <span class="number">1</span>),</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(inorder.<span class="built_in">begin</span>(), inorder.<span class="built_in">begin</span>() + rootPos));</span><br><span class="line">    root-&gt;right =</span><br><span class="line">        <span class="built_in">function</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(preorder.<span class="built_in">begin</span>() + rootPos + <span class="number">1</span>, preorder.<span class="built_in">end</span>()),</span><br><span class="line">                 <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(inorder.<span class="built_in">begin</span>() + rootPos + <span class="number">1</span>, inorder.<span class="built_in">end</span>()));</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;preorder, vector&lt;<span class="type">int</span>&gt; &amp;inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">function</span>(preorder, inorder);</span><br><span class="line">    <span class="comment">// 203/203 cases passed (40 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 18.57 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 14.97 % of cpp submissions (72.1 MB)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="[114] 二叉树展开为链表"></a>[114] 二叉树展开为链表</h2><p><strong>tree | depth-first-search</strong></p>
<p>2022/03/09</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span></span><br><span class="line"><span class="comment"> * right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">flatten</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">flatten</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">auto</span> tmp = root-&gt;right;</span><br><span class="line">    root-&gt;right = root-&gt;left;</span><br><span class="line">    root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;right) root = root-&gt;right;</span><br><span class="line">    root-&gt;right = tmp;</span><br><span class="line">    <span class="comment">// 225/225 cases passed (4 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 84.61 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 74.92 % of cpp submissions (12.3 MB)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="[128] 最长连续序列"></a>[128] 最长连续序列</h2><p><strong>array | union-find</strong></p>
<p>2022/03/10</p>
<p>感觉照着 tag 用并查集还会更慢==</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> nowPath = <span class="number">1</span>, maxPath = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">        nowPath++;</span><br><span class="line">        maxPath = <span class="built_in">max</span>(maxPath, nowPath);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">        nowPath = <span class="number">1</span>;</span><br><span class="line">        maxPath = <span class="built_in">max</span>(maxPath, nowPath);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxPath;</span><br><span class="line">    <span class="comment">// 70/70 cases passed (28 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 98.89 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 98.61 % of cpp submissions (21.7 MB)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="[141] 环形链表"></a>[141] 环形链表</h2><p><strong>linked-list | two-pointers</strong></p>
<p>2022/03/10</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> front = head, behind = head;</span><br><span class="line">    <span class="keyword">while</span> (front-&gt;next &amp;&amp; front-&gt;next-&gt;next) &#123;</span><br><span class="line">      front = front-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (front == behind) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      front = front-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (front == behind) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      behind = behind-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (front == behind) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 21/21 cases passed (8 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 93.51 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 53.45 % of cpp submissions (7.9 MB)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="[142] 环形链表 II"></a>[142] 环形链表 II</h2><p><strong>linked-list | two-pointers</strong></p>
<p>2022/03/12</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">auto</span> front = head, behind = head;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!front-&gt;next) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (front == behind) <span class="keyword">return</span> behind;</span><br><span class="line">      &#125;</span><br><span class="line">      behind = behind-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 16/16 cases passed (284 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 8.76 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 95.55 % of cpp submissions (7.3 MB)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="[146] LRU 缓存"></a>[146] LRU 缓存</h2><p><strong>design</strong></p>
<p>2022/03/12</p>
<p>利用指针或者迭代器来避免排序，虽然最后结果还是很慢但至少不超时了==</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  map&lt;<span class="type">int</span>, list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;::iterator&gt; cache;</span><br><span class="line">  list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; hash;</span><br><span class="line">  <span class="type">int</span> cap;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">    cap = capacity;</span><br><span class="line">    <span class="comment">// 22/22 cases passed (452 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 14.15 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 6.91 % of cpp submissions (170.2 MB)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.<span class="built_in">find</span>(key) == cache.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    hash.<span class="built_in">push_front</span>(*cache[key]);</span><br><span class="line">    hash.<span class="built_in">erase</span>(cache[key]);</span><br><span class="line">    cache[key] = hash.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">return</span> (*cache[key]).second;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.<span class="built_in">find</span>(key) != cache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      hash.<span class="built_in">emplace_front</span>(key, value);</span><br><span class="line">      hash.<span class="built_in">erase</span>(cache[key]);</span><br><span class="line">      cache[key] = hash.<span class="built_in">begin</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (cache.<span class="built_in">size</span>() &gt;= cap) &#123;</span><br><span class="line">        cache.<span class="built_in">erase</span>(hash.<span class="built_in">back</span>().first);</span><br><span class="line">        hash.<span class="built_in">pop_back</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      hash.<span class="built_in">emplace_front</span>(key, value);</span><br><span class="line">      cache[key] = hash.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="[148] 排序链表"></a>[148] 排序链表</h2><p><strong>linked-list | sort</strong></p>
<p>2022/03/13</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    vector&lt;ListNode*&gt; list;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">      list.<span class="built_in">emplace_back</span>(head);</span><br><span class="line">      head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(list.<span class="built_in">begin</span>(), list.<span class="built_in">end</span>(),</span><br><span class="line">         [](ListNode* a, ListNode* b) &#123; <span class="keyword">return</span> a-&gt;val &lt; b-&gt;val; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; list.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      list[i]-&gt;next = list[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    list.<span class="built_in">back</span>()-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> list[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 28/28 cases passed (84 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 77.51 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 68.35 % of cpp submissions (30.5 MB)</span></span><br><span class="line">    <span class="comment">//哈哈这解法太妙了，居然还是我自己想出来的</span></span><br><span class="line">    <span class="comment">/* if (!head) return nullptr;</span></span><br><span class="line"><span class="comment">    if (!head-&gt;next) return head;</span></span><br><span class="line"><span class="comment">    auto nextList = sortList(head-&gt;next);</span></span><br><span class="line"><span class="comment">    if (nextList-&gt;val &gt;= head-&gt;val) &#123;</span></span><br><span class="line"><span class="comment">      auto tmp = head;</span></span><br><span class="line"><span class="comment">      tmp-&gt;next = nextList;</span></span><br><span class="line"><span class="comment">      nextList = tmp;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    auto ans = nextList;</span></span><br><span class="line"><span class="comment">    while (nextList-&gt;val &lt; head-&gt;val) &#123;</span></span><br><span class="line"><span class="comment">      if (nextList-&gt;next) &#123;</span></span><br><span class="line"><span class="comment">        if (nextList-&gt;next-&gt;val &gt;= head-&gt;val) &#123;</span></span><br><span class="line"><span class="comment">          auto tmp = head;</span></span><br><span class="line"><span class="comment">          tmp-&gt;next = nextList-&gt;next;</span></span><br><span class="line"><span class="comment">          nextList-&gt;next = tmp;</span></span><br><span class="line"><span class="comment">          break;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125; else &#123;</span></span><br><span class="line"><span class="comment">        nextList-&gt;next = head;</span></span><br><span class="line"><span class="comment">        nextList-&gt;next-&gt;next = nullptr;</span></span><br><span class="line"><span class="comment">        break;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      nextList = nextList-&gt;next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return ans;</span></span><br><span class="line"><span class="comment">    // 28/28 cases passed (728 ms)</span></span><br><span class="line"><span class="comment">    // Your runtime beats 5 % of cpp submissions</span></span><br><span class="line"><span class="comment">    // Your memory usage beats 65.94 % of cpp submissions (30.6 MB) */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="[152] 乘积最大子数组"></a>[152] 乘积最大子数组</h2><p><strong>array | dynamic-programming</strong></p>
<p>2022/03/13</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dpMax</span><span class="params">(nums.size(), <span class="number">1</span>)</span>, <span class="title">dpMin</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">    dpMax[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dpMin[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      dpMin[i] =</span><br><span class="line">          <span class="built_in">min</span>(nums[i], <span class="built_in">min</span>(dpMin[i - <span class="number">1</span>] * nums[i], dpMax[i - <span class="number">1</span>] * nums[i]));</span><br><span class="line">      dpMax[i] =</span><br><span class="line">          <span class="built_in">max</span>(nums[i], <span class="built_in">max</span>(dpMin[i - <span class="number">1</span>] * nums[i], dpMax[i - <span class="number">1</span>] * nums[i]));</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, dpMax[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="comment">// 188/188 cases passed (4 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 92.06 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 21.33 % of cpp submissions (13.8 MB)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="[207] 课程表"></a>[207] 课程表</h2><p><strong>depth-first-search | breadth-first-search | graph | topological-sort</strong></p>
<p>2022/03/15</p>
<p><strong>拓扑排序</strong>：</p>
<p>方法是重复寻找一个入度为 0 的顶点，将该顶点从图中删除（即放进一个队列里存着，这个队列的顺序就是最后的拓扑排序，具体见程序），并将该结点及其所有的出边从图中删除（即该结点指向的结点的入度减 1），最终若图中全为入度为 1 的点，则这些点至少组成一个回路。</p>
<p>采用邻接矩阵存储时，遍历二维数组，求各顶点入度的时间复杂度是 O(n^2)。 遍历所有结点，找出入度为 0 的结点的时间复杂度是 O(n)。对于 n 个入度为 0 的结点，删除他们的出边的复杂度为 O(n^2)。 所以总的复杂度为 O(n^2)。</p>
<p>对于邻接表，遍历所有边，求各顶点入度的时间复杂度是 O(e)，即边的个数。遍历所有结点，找出入度为 0 的结点的时间复杂度是 O(n)，即顶点的个数。遍历所有边，删除入度为 0 的结点的出边的复杂度为 O(e)，即边的个数。所以总的时间复杂度是 O(n+e)。</p>
<p>至于这道题我用了邻接矩阵的方法，感觉写起来简单</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">edge</span>(numCourses, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; i : prerequisites) &#123;</span><br><span class="line">      inDegree[i[<span class="number">1</span>]]++;</span><br><span class="line">      edge[i[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(i[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span> &amp;&amp; !edge[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">          <span class="keyword">while</span> (!edge[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            inDegree[edge[i].<span class="built_in">back</span>()]--;</span><br><span class="line">            edge[i].<span class="built_in">pop_back</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          flag = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; i : inDegree) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 51/51 cases passed (36 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 12.15 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 89.87 % of cpp submissions (12.9 MB)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="215-数组中的第-K-个最大元素"><a href="#215-数组中的第-K-个最大元素" class="headerlink" title="[215] 数组中的第 K 个最大元素"></a>[215] 数组中的第 K 个最大元素</h2><p><strong>divide-and-conquer | heap</strong></p>
<p>2022/03/15</p>
<p>不明白这题想干嘛==</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() - k];</span><br><span class="line">    <span class="comment">// 32/32 cases passed (8 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 72.52 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 85.7 % of cpp submissions (9.7 MB)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Hard"><a href="#Hard" class="headerlink" title="Hard"></a>Hard</h1><h2 id="149-直线上最多的点数"><a href="#149-直线上最多的点数" class="headerlink" title="[149] 直线上最多的点数"></a>[149] 直线上最多的点数</h2><p><strong>hash-table | math</strong></p>
<p>2022/03/02</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points.<span class="built_in">size</span>() &lt;= <span class="number">2</span>) <span class="keyword">return</span> points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> Max = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="type">int</span> same = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; points.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (points[i] == points[j]) &#123;</span><br><span class="line">          same++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          count++;</span><br><span class="line">          <span class="type">long</span> <span class="type">long</span> xDiff = (<span class="type">long</span> <span class="type">long</span>)(points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]);</span><br><span class="line">          <span class="type">long</span> <span class="type">long</span> yDiff = (<span class="type">long</span> <span class="type">long</span>)(points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]);</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; points.<span class="built_in">size</span>(); k++)</span><br><span class="line">            <span class="keyword">if</span> (xDiff * (points[i][<span class="number">1</span>] - points[k][<span class="number">1</span>]) ==</span><br><span class="line">                yDiff * (points[i][<span class="number">0</span>] -</span><br><span class="line">                         points[k][<span class="number">0</span>]))  <span class="comment">//利用这种方法化解公倍数，妙啊</span></span><br><span class="line">              count++;</span><br><span class="line">        &#125;</span><br><span class="line">        Max = <span class="built_in">max</span>(Max, same + count);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Max &gt; points.<span class="built_in">size</span>() / <span class="number">2</span>) <span class="keyword">return</span> Max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Max;</span><br><span class="line">    <span class="comment">// 34/34 cases passed (12 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 58.62 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 94.54 % of cpp submissions (6.9 MB)</span></span><br><span class="line">    <span class="comment">//还真就是一个一个找，我佛辣</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="[10] 正则表达式匹配"></a>[10] 正则表达式匹配</h2><p><strong>string | dynamic-programming | backtracking</strong></p>
<p>2022/03/02</p>
<p>一開始是從前向後判斷的，後來想想因爲*的緣故從後向前處理比較好，這裡運用了遞歸，效率上差動規很多</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> si = s.<span class="built_in">size</span>() - <span class="number">1</span>, pi = p.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">while</span> (pi &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p[pi] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (si &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[si] == p[pi] || p[pi] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">          si--;</span><br><span class="line">          pi--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        string tmpP = p.<span class="built_in">substr</span>(<span class="number">0</span>, pi - <span class="number">1</span>);</span><br><span class="line">        string tmpS = s.<span class="built_in">substr</span>(<span class="number">0</span>, si + <span class="number">1</span>);</span><br><span class="line">        <span class="type">bool</span> flag;</span><br><span class="line">        <span class="type">int</span> k = tmpS.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> ((flag = (!<span class="built_in">isMatch</span>(tmpS, tmpP))) &amp;&amp; k--) &#123;</span><br><span class="line">          tmpP = tmpP + p[pi - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !flag;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> si == pi;</span><br><span class="line">    <span class="comment">/* if (p[0] == &#x27;*&#x27;) return 0;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; s &lt;&lt; &quot; &quot; &lt;&lt; p &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    int si = 0, pi = 0;</span></span><br><span class="line"><span class="comment">    while (si &lt; s.size() || pi &lt; p.size()) &#123;</span></span><br><span class="line"><span class="comment">      if (p[pi] != &#x27;*&#x27;) &#123;</span></span><br><span class="line"><span class="comment">        if (s[si] == p[pi] || p[pi] == &#x27;.&#x27;) &#123;</span></span><br><span class="line"><span class="comment">          si++;</span></span><br><span class="line"><span class="comment">          pi++;</span></span><br><span class="line"><span class="comment">        &#125; else &#123;</span></span><br><span class="line"><span class="comment">          if (pi == p.size() - 1 || p[pi + 1] != &#x27;*&#x27;) &#123;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; 1 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">            return 0;</span></span><br><span class="line"><span class="comment">          &#125; else &#123;</span></span><br><span class="line"><span class="comment">            pi++;</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125; else &#123;</span></span><br><span class="line"><span class="comment">        string tmpP = p.substr(pi + 1);</span></span><br><span class="line"><span class="comment">        string tmpS = s.substr(si);</span></span><br><span class="line"><span class="comment">        bool flag;</span></span><br><span class="line"><span class="comment">        int k = tmpS.size() + 1;</span></span><br><span class="line"><span class="comment">        while ((flag = (!isMatch(tmpS, tmpP))) &amp;&amp; k--) &#123;</span></span><br><span class="line"><span class="comment">          tmpP = p[pi - 1] + tmpP;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return !flag;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return si == s.size() &amp;&amp; pi == p.size(); */</span></span><br><span class="line">    <span class="comment">// 353/353 cases passed (192 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 5.29 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 14.13 % of cpp submissions (9.4 MB)</span></span><br><span class="line">    <span class="comment">//动规应该快一点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="[23] 合并 K 个升序链表"></a>[23] 合并 K 个升序链表</h2><p><strong>linked-list | divide-and-conquer | heap</strong></p>
<p>2022/03/02</p>
<p>解釋一下 divide and conquer，字面意思分而治之，遞歸拆散數組，直到拆成一對或者一個，然後回溯處理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">  int val;</span></span><br><span class="line"><span class="comment">  ListNode* next;</span></span><br><span class="line"><span class="comment">  ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment">  ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment">  ListNode(int x, ListNode* next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;; */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!l1) &#123;</span><br><span class="line">      <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!l2) &#123;</span><br><span class="line">      <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *l3;</span><br><span class="line">    <span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;</span><br><span class="line">      l3 = l1;</span><br><span class="line">      l3-&gt;next = <span class="built_in">mergeTwoLists</span>(l1-&gt;next, l2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      l3 = l2;</span><br><span class="line">      l3-&gt;next = <span class="built_in">mergeTwoLists</span>(l1, l2-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l3;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lists.<span class="built_in">empty</span>())</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (lists.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (lists.<span class="built_in">size</span>() == <span class="number">2</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(lists[<span class="number">0</span>], lists[<span class="number">1</span>]);</span><br><span class="line">    vector&lt;ListNode *&gt; tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lists.<span class="built_in">size</span>() / <span class="number">2</span>; i++) &#123;</span><br><span class="line">      tmp.<span class="built_in">push_back</span>(lists.<span class="built_in">back</span>());</span><br><span class="line">      lists.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(<span class="built_in">mergeKLists</span>(lists), <span class="built_in">mergeKLists</span>(tmp));</span><br><span class="line">    <span class="comment">// 133/133 cases passed (16 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 94.55 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 5 % of cpp submissions (24.9 MB)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="[32] 最长有效括号"></a>[32] 最长有效括号</h2><p>2022/03/03</p>
<p><strong>string | dynamic-programming</strong></p>
<p>用了好想的方法，不然的话时间和空间复杂度应该还可以压缩一倍</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pos</span><span class="params">(s.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">          <span class="keyword">if</span> (s[j] == <span class="string">&#x27;(&#x27;</span> &amp;&amp; pos[j] == <span class="number">-1</span>) &#123;</span><br><span class="line">            pos[j] = i;</span><br><span class="line">            pos[i] = j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">length</span><span class="params">(s.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    length[<span class="number">0</span>] = pos[<span class="number">0</span>] == <span class="number">-1</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> Max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pos[i] != <span class="number">-1</span>) &#123;</span><br><span class="line">        length[i] = length[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        Max = <span class="built_in">max</span>(Max, length[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Max;</span><br><span class="line">    <span class="comment">// 231/231 cases passed (8 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 12.95 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 8.5 % of cpp submissions (7.5 MB)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="[42] 接雨水"></a>[42] 接雨水</h2><p>2022/03/03</p>
<p><strong>array | two-pointers | stack</strong></p>
<p>标的是双指针，结果是靠着 DP 解的，牛 p 嗷</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(height.size())</span>, <span class="title">right</span><span class="params">(height.size())</span></span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; height.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      left[i] = <span class="built_in">max</span>(left[i - <span class="number">1</span>], height[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = height.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      right[i] = <span class="built_in">max</span>(right[i + <span class="number">1</span>], height[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      ans += <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">min</span>(right[i], left[i]) - height[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="comment">// 321/321 cases passed (8 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 80.65 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 10.41 % of cpp submissions (17.8 MB)</span></span><br><span class="line">    <span class="comment">/* int left = 0, right = height.size() - 1;</span></span><br><span class="line"><span class="comment">    int ans = 0;</span></span><br><span class="line"><span class="comment">    while (left &lt; right) &#123;</span></span><br><span class="line"><span class="comment">      if (height[left] &lt; height[right]) &#123;</span></span><br><span class="line"><span class="comment">        for (int i = left; i &lt;= right; i++) &#123;</span></span><br><span class="line"><span class="comment">          if (height[i] &lt; height[left]) &#123;</span></span><br><span class="line"><span class="comment">            ans += (height[left] - height[i]);</span></span><br><span class="line"><span class="comment">            height[i] = height[left];</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        int tmp = height[left];</span></span><br><span class="line"><span class="comment">        while (left &lt; height.size() &amp;&amp; height[left] == tmp) &#123;</span></span><br><span class="line"><span class="comment">          left++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125; else &#123;</span></span><br><span class="line"><span class="comment">        for (int i = left; i &lt;= right; i++) &#123;</span></span><br><span class="line"><span class="comment">          if (height[i] &lt; height[right]) &#123;</span></span><br><span class="line"><span class="comment">            ans += (height[right] - height[i]);</span></span><br><span class="line"><span class="comment">            height[i] = height[right];</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        int tmp = height[right];</span></span><br><span class="line"><span class="comment">        while (right &gt;= 0 &amp;&amp; height[right] == tmp) &#123;</span></span><br><span class="line"><span class="comment">          right--;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return ans; */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="[76] 最小覆盖子串"></a>[76] 最小覆盖子串</h2><p><strong>hash-table | two-pointers | string | sliding-window</strong></p>
<p>2022/03/05</p>
<p>竟然是 hard，难以置信</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; hashS, vector&lt;<span class="type">int</span>&gt;&amp; hashT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">58</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hashT[i] &gt; hashS[i]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> Min = INT_MAX, minLeft = <span class="number">0</span>, minRight = <span class="number">-1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hashS</span><span class="params">(<span class="number">58</span>, <span class="number">0</span>)</span>, <span class="title">hashT</span><span class="params">(<span class="number">58</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : t) &#123;</span><br><span class="line">      hashT[i - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">judge</span>(hashS, hashT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (right == s.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        hashS[s[++right] - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; Min) &#123;</span><br><span class="line">          Min = right - left + <span class="number">1</span>;</span><br><span class="line">          minLeft = left;</span><br><span class="line">          minRight = right;</span><br><span class="line">        &#125;</span><br><span class="line">        hashS[s[left++] - <span class="string">&#x27;A&#x27;</span>]--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">substr</span>(minLeft, minRight - minLeft + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 266/266 cases passed (96 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 24.32 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 97.3 % of cpp submissions (7.4 MB)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="[84] 柱状图中最大的矩形"></a>[84] 柱状图中最大的矩形</h2><p><strong>array | stack</strong></p>
<p>2022/03/06</p>
<p>本题的难点主要在于如何找到某一个柱子构成矩形而所需要延伸的最大程度，利用单调栈可以实现这一点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">    heights.<span class="built_in">insert</span>(heights.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">    heights.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; indexStack;</span><br><span class="line">    <span class="type">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heights.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!indexStack.<span class="built_in">empty</span>() &amp;&amp; heights[i] &lt; heights[indexStack.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">        <span class="type">int</span> height = heights[indexStack.<span class="built_in">top</span>()];</span><br><span class="line">        indexStack.<span class="built_in">pop</span>();</span><br><span class="line">        area = <span class="built_in">max</span>(area, (i - indexStack.<span class="built_in">top</span>() - <span class="number">1</span>) * height);</span><br><span class="line">      &#125;</span><br><span class="line">      indexStack.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">    <span class="comment">// 98/98 cases passed (116 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 62.95 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 32.66 % of cpp submissions (75.3 MB)</span></span><br><span class="line">    <span class="comment">/* int heightNow = heights[0];</span></span><br><span class="line"><span class="comment">    int areaNow = heightNow;</span></span><br><span class="line"><span class="comment">    int Max = areaNow;</span></span><br><span class="line"><span class="comment">    for (int i = 1; i &lt; heights.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">      if (heights[i] &lt; heightNow) &#123;</span></span><br><span class="line"><span class="comment">        areaNow = areaNow / heightNow * heights[i] + heights[i];</span></span><br><span class="line"><span class="comment">        heightNow = heights[i];</span></span><br><span class="line"><span class="comment">        Max = max(Max, areaNow);</span></span><br><span class="line"><span class="comment">      &#125; else if (heights[i] &gt; heightNow) &#123;</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt; newHeights(heights.begin() + i, heights.end());</span></span><br><span class="line"><span class="comment">        areaNow += heightNow;</span></span><br><span class="line"><span class="comment">        Max = max(Max, max(areaNow, largestRectangleArea(newHeights)));</span></span><br><span class="line"><span class="comment">      &#125; else &#123;</span></span><br><span class="line"><span class="comment">        areaNow += heightNow;</span></span><br><span class="line"><span class="comment">        Max = max(Max, areaNow);</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return Max;</span></span><br><span class="line"><span class="comment">    //有些不超时了，有些还是超时 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* vector&lt;int&gt; left(heights.size()), right(heights.size());</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; heights.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">      for (int j = i; j &gt;= 0; j--)</span></span><br><span class="line"><span class="comment">        if (heights[j] &lt; heights[i]) &#123;</span></span><br><span class="line"><span class="comment">          left[i] = j + 1;</span></span><br><span class="line"><span class="comment">          break;</span></span><br><span class="line"><span class="comment">        &#125; else if (j == 0)</span></span><br><span class="line"><span class="comment">          left[i] = 0;</span></span><br><span class="line"><span class="comment">      for (int j = i; j &lt; heights.size(); j++)</span></span><br><span class="line"><span class="comment">        if (heights[j] &lt; heights[i]) &#123;</span></span><br><span class="line"><span class="comment">          right[i] = j - 1;</span></span><br><span class="line"><span class="comment">          break;</span></span><br><span class="line"><span class="comment">        &#125; else if (j == heights.size() - 1)</span></span><br><span class="line"><span class="comment">          right[i] = heights.size() - 1;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    int Max = 0;</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; heights.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">      Max = max(Max, ((right[i] - left[i] + 1) * heights[i]));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return Max;</span></span><br><span class="line"><span class="comment">    // 两组一维dp也超时 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* vector&lt;vector&lt;int&gt;&gt; dp(heights.size(),</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt;(heights.size(), 0)); for (int i = 0; i &lt;</span></span><br><span class="line"><span class="comment">    heights.size(); i++) &#123; dp[i][i] = heights[i]; for (int j = i +</span></span><br><span class="line"><span class="comment">    1; j &lt; heights.size(); j++) &#123; dp[i][j] = min(dp[i][j - 1],</span></span><br><span class="line"><span class="comment">    heights[j]);</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    int Max = 0;</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; heights.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">      Max = max(Max, dp[i][i]);</span></span><br><span class="line"><span class="comment">      for (int j = i + 1; j &lt; heights.size(); j++) &#123;</span></span><br><span class="line"><span class="comment">        Max = max(Max, dp[i][j] * (j - i + 1));</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return Max;</span></span><br><span class="line"><span class="comment">    //二维dp超时 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="[85] 最大矩形"></a>[85] 最大矩形</h2><p><strong>array | hash-table | dynamic-programming | stack</strong></p>
<p>2022/03/06</p>
<p>解法看注释</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">function</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; indexStack;</span><br><span class="line">    <span class="type">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heights.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!indexStack.<span class="built_in">empty</span>() &amp;&amp; heights[i] &lt; heights[indexStack.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">        <span class="type">int</span> height = heights[indexStack.<span class="built_in">top</span>()];</span><br><span class="line">        indexStack.<span class="built_in">pop</span>();</span><br><span class="line">        area = <span class="built_in">max</span>(area, (i - indexStack.<span class="built_in">top</span>() - <span class="number">1</span>) * height);</span><br><span class="line">      &#125;</span><br><span class="line">      indexStack.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maximalRectangle</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rows = matrix.<span class="built_in">size</span>(), cols = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">heights</span><span class="params">(cols + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">        heights[j + <span class="number">1</span>] =</span><br><span class="line">            matrix[i][j] == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : heights[j + <span class="number">1</span>] + matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      area = <span class="built_in">max</span>(area, <span class="built_in">function</span>(heights));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">    <span class="comment">// 73/73 cases passed (32 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 90.62 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 54.56 % of cpp submissions (13 MB)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    每一层看作是柱状图，可以套用84题柱状图的最大面积。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    第一层柱状图的高度[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;]，最大面积为1；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    第二层柱状图的高度[&quot;2&quot;,&quot;0&quot;,&quot;2&quot;,&quot;1&quot;,&quot;1&quot;]，最大面积为3；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    第三层柱状图的高度[&quot;3&quot;,&quot;1&quot;,&quot;3&quot;,&quot;2&quot;,&quot;2&quot;]，最大面积为6；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    第四层柱状图的高度[&quot;4&quot;,&quot;0&quot;,&quot;0&quot;,&quot;3&quot;,&quot;0&quot;]，最大面积为4； */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="[124] 二叉树中的最大路径和"></a>[124] 二叉树中的最大路径和</h2><p><strong>tree | depth-first-search</strong></p>
<p>2022/03/10</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span></span><br><span class="line"><span class="comment"> * right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">function</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0</span>,</span><br><span class="line">               root-&gt;val + <span class="built_in">max</span>(<span class="built_in">function</span>(root-&gt;left), <span class="built_in">function</span>((root-&gt;right))));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(root-&gt;val + <span class="built_in">function</span>(root-&gt;left) + <span class="built_in">function</span>(root-&gt;right),</span><br><span class="line">               <span class="built_in">max</span>(<span class="built_in">maxPathSum</span>(root-&gt;left), <span class="built_in">maxPathSum</span>(root-&gt;right)));</span><br><span class="line">    <span class="comment">// 94/94 cases passed (316 ms)</span></span><br><span class="line">    <span class="comment">// Your runtime beats 5.2 % of cpp submissions</span></span><br><span class="line">    <span class="comment">// Your memory usage beats 55.73 % of cpp submissions (27 MB)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">零泽</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lz37.github.io/2022/03/02/LeetCode%E5%88%B7%E9%A1%8C%E7%AD%86%E8%A8%98(03.02-03.15)/">https://lz37.github.io/2022/03/02/LeetCode%E5%88%B7%E9%A1%8C%E7%AD%86%E8%A8%98(03.02-03.15)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lz37.github.io" target="_blank">零泽</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/LeetCode/">LeetCode</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/lz37/images/img/29535589_84295672_p0_Archive%20%20%E9%87%8C%E4%B8%AA%E4%BA%BA%E5%AD%98%E6%A1%A3%E5%A4%84_%E8%BE%89%E7%8F%96%E7%AA%81%E5%9B%B4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/16/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0(03.16-03.19)/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/lz37/images/img/29535589_84295672_p0_Archive%20%20%E9%87%8C%E4%B8%AA%E4%BA%BA%E5%AD%98%E6%A1%A3%E5%A4%84_%E8%BE%89%E7%8F%96%E7%AA%81%E5%9B%B4.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">LeetCode刷题笔记(03.16-03.19)</div></div></a></div><div class="next-post pull-right"><a href="/2022/02/27/html%E5%92%8Cmarkdown%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/lz37/images/img/29535589_72608843_p0_Archive%20%20%E9%87%8C%E4%B8%AA%E4%BA%BA%E5%AD%98%E6%A1%A3%E5%A4%84_(%20%E2%80%A2%20%CC%80%CF%89%E2%80%A2%CC%81%20)%E2%9C%A7Great%20Crisis%20II.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">html和markdown的特殊字符</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/02/11/LeetCode.1091.130.797(广度优先搜索&深度优先搜索)/" title="LeetCode.1091.130.797(广度优先搜索&深度优先搜索)"><img class="cover" src="https://cdn.jsdelivr.net/gh/lz37/images/img/29535589_84295672_p0_Archive%20%20%E9%87%8C%E4%B8%AA%E4%BA%BA%E5%AD%98%E6%A1%A3%E5%A4%84_%E8%BE%89%E7%8F%96%E7%AA%81%E5%9B%B4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-11</div><div class="title">LeetCode.1091.130.797(广度优先搜索&深度优先搜索)</div></div></a></div><div><a href="/2022/02/23/LeetCode.1143.583.72.322.343(动态规划)/" title="LeetCode.1143.583.72.322.343(动态规划)"><img class="cover" src="https://cdn.jsdelivr.net/gh/lz37/images/img/29535589_84295672_p0_Archive%20%20%E9%87%8C%E4%B8%AA%E4%BA%BA%E5%AD%98%E6%A1%A3%E5%A4%84_%E8%BE%89%E7%8F%96%E7%AA%81%E5%9B%B4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">LeetCode.1143.583.72.322.343(动态规划)</div></div></a></div><div><a href="/2022/02/07/LeetCode.153.162(二分查找)/" title="LeetCode.153.162(二分查找)"><img class="cover" src="https://cdn.jsdelivr.net/gh/lz37/images/img/29535589_84295672_p0_Archive%20%20%E9%87%8C%E4%B8%AA%E4%BA%BA%E5%AD%98%E6%A1%A3%E5%A4%84_%E8%BE%89%E7%8F%96%E7%AA%81%E5%9B%B4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-07</div><div class="title">LeetCode.153.162(二分查找)</div></div></a></div><div><a href="/2022/02/13/LeetCode.17.22.79(递归&回溯)/" title="LeetCode.17.22.79(递归&回溯)"><img class="cover" src="https://cdn.jsdelivr.net/gh/lz37/images/img/29535589_84295672_p0_Archive%20%20%E9%87%8C%E4%B8%AA%E4%BA%BA%E5%AD%98%E6%A1%A3%E5%A4%84_%E8%BE%89%E7%8F%96%E7%AA%81%E5%9B%B4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-13</div><div class="title">LeetCode.17.22.79(递归&回溯)</div></div></a></div><div><a href="/2022/02/10/LeetCode.200.547.117.572(广度优先搜索&深度优先搜索)/" title="LeetCode.200.547.117.572(广度优先搜索&深度优先搜索)"><img class="cover" src="https://cdn.jsdelivr.net/gh/lz37/images/img/29535589_84295672_p0_Archive%20%20%E9%87%8C%E4%B8%AA%E4%BA%BA%E5%AD%98%E6%A1%A3%E5%A4%84_%E8%BE%89%E7%8F%96%E7%AA%81%E5%9B%B4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-10</div><div class="title">LeetCode.200.547.117.572(广度优先搜索&深度优先搜索)</div></div></a></div><div><a href="/2022/02/02/LeetCode.21.206(递归&回溯)/" title="LeetCode.21.206(递归&回溯)"><img class="cover" src="https://cdn.jsdelivr.net/gh/lz37/images/img/29535589_84295672_p0_Archive%20%20%E9%87%8C%E4%B8%AA%E4%BA%BA%E5%AD%98%E6%A1%A3%E5%A4%84_%E8%BE%89%E7%8F%96%E7%AA%81%E5%9B%B4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-02</div><div class="title">LeetCode.21.206(递归&回溯)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/24218478_84738252_p0_%EF%BF%A6ANKE_the_moon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">零泽</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lz37"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Easy"><span class="toc-number">1.</span> <span class="toc-text">Easy</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#202-%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">[202] 快乐数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.2.</span> <span class="toc-text">[94] 二叉树的中序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.3.</span> <span class="toc-text">[101] 对称二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">1.4.</span> <span class="toc-text">[104] 二叉树的最大深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="toc-number">1.5.</span> <span class="toc-text">[160] 相交链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="toc-number">1.6.</span> <span class="toc-text">[169] 多数元素</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Medium"><span class="toc-number">2.</span> <span class="toc-text">Medium</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#201-%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E"><span class="toc-number">2.1.</span> <span class="toc-text">[201] 数字范围按位与</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#384-%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.</span> <span class="toc-text">[384] 打乱数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="toc-number">2.3.</span> <span class="toc-text">[31] 下一个排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="toc-number">2.4.</span> <span class="toc-text">[48] 旋转图像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="toc-number">2.5.</span> <span class="toc-text">[49] 字母异位词分组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-number">2.6.</span> <span class="toc-text">[56] 合并区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">2.7.</span> <span class="toc-text">[64] 最小路径和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB"><span class="toc-number">2.8.</span> <span class="toc-text">[75] 颜色分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">2.9.</span> <span class="toc-text">[96] 不同的二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">2.10.</span> <span class="toc-text">[98] 验证二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.11.</span> <span class="toc-text">[102] 二叉树的层序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.12.</span> <span class="toc-text">[105] 从前序与中序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="toc-number">2.13.</span> <span class="toc-text">[114] 二叉树展开为链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-number">2.14.</span> <span class="toc-text">[128] 最长连续序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-number">2.15.</span> <span class="toc-text">[141] 环形链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II"><span class="toc-number">2.16.</span> <span class="toc-text">[142] 环形链表 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#146-LRU-%E7%BC%93%E5%AD%98"><span class="toc-number">2.17.</span> <span class="toc-text">[146] LRU 缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">2.18.</span> <span class="toc-text">[148] 排序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">2.19.</span> <span class="toc-text">[152] 乘积最大子数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#207-%E8%AF%BE%E7%A8%8B%E8%A1%A8"><span class="toc-number">2.20.</span> <span class="toc-text">[207] 课程表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%AC-K-%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-number">2.21.</span> <span class="toc-text">[215] 数组中的第 K 个最大元素</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hard"><span class="toc-number">3.</span> <span class="toc-text">Hard</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#149-%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">[149] 直线上最多的点数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">3.2.</span> <span class="toc-text">[10] 正则表达式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%90%88%E5%B9%B6-K-%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.</span> <span class="toc-text">[23] 合并 K 个升序链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="toc-number">3.4.</span> <span class="toc-text">[32] 最长有效括号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-number">3.5.</span> <span class="toc-text">[42] 接雨水</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="toc-number">3.6.</span> <span class="toc-text">[76] 最小覆盖子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2"><span class="toc-number">3.7.</span> <span class="toc-text">[84] 柱状图中最大的矩形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2"><span class="toc-number">3.8.</span> <span class="toc-text">[85] 最大矩形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">3.9.</span> <span class="toc-text">[124] 二叉树中的最大路径和</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/06/Markdown%E4%B8%ADMermaid%E7%9A%84%E4%BD%BF%E7%94%A8/" title="Markdown中Mermaid的使用"><img src="https://cdn.jsdelivr.net/gh/lz37/images/img/29535589_72608843_p0_Archive%20%20%E9%87%8C%E4%B8%AA%E4%BA%BA%E5%AD%98%E6%A1%A3%E5%A4%84_(%20%E2%80%A2%20%CC%80%CF%89%E2%80%A2%CC%81%20)%E2%9C%A7Great%20Crisis%20II.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Markdown中Mermaid的使用"/></a><div class="content"><a class="title" href="/2022/04/06/Markdown%E4%B8%ADMermaid%E7%9A%84%E4%BD%BF%E7%94%A8/" title="Markdown中Mermaid的使用">Markdown中Mermaid的使用</a><time datetime="2022-04-06T11:40:00.000Z" title="发表于 2022-04-06 19:40:00">2022-04-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0(04.05-)/" title="LeetCode刷题笔记(04.05-)"><img src="https://cdn.jsdelivr.net/gh/lz37/images/img/29535589_84295672_p0_Archive%20%20%E9%87%8C%E4%B8%AA%E4%BA%BA%E5%AD%98%E6%A1%A3%E5%A4%84_%E8%BE%89%E7%8F%96%E7%AA%81%E5%9B%B4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode刷题笔记(04.05-)"/></a><div class="content"><a class="title" href="/2022/04/05/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0(04.05-)/" title="LeetCode刷题笔记(04.05-)">LeetCode刷题笔记(04.05-)</a><time datetime="2022-04-05T05:11:00.000Z" title="发表于 2022-04-05 13:11:00">2022-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/20/%E8%93%9D%E6%A1%A5%E6%9D%AF/" title="蓝桥杯"><img src="https://cdn.jsdelivr.net/gh/lz37/images/img/29535589_84295672_p0_Archive%20%20%E9%87%8C%E4%B8%AA%E4%BA%BA%E5%AD%98%E6%A1%A3%E5%A4%84_%E8%BE%89%E7%8F%96%E7%AA%81%E5%9B%B4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="蓝桥杯"/></a><div class="content"><a class="title" href="/2022/03/20/%E8%93%9D%E6%A1%A5%E6%9D%AF/" title="蓝桥杯">蓝桥杯</a><time datetime="2022-03-20T03:38:00.000Z" title="发表于 2022-03-20 11:38:00">2022-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/16/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0(03.16-03.19)/" title="LeetCode刷题笔记(03.16-03.19)"><img src="https://cdn.jsdelivr.net/gh/lz37/images/img/29535589_84295672_p0_Archive%20%20%E9%87%8C%E4%B8%AA%E4%BA%BA%E5%AD%98%E6%A1%A3%E5%A4%84_%E8%BE%89%E7%8F%96%E7%AA%81%E5%9B%B4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode刷题笔记(03.16-03.19)"/></a><div class="content"><a class="title" href="/2022/03/16/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0(03.16-03.19)/" title="LeetCode刷题笔记(03.16-03.19)">LeetCode刷题笔记(03.16-03.19)</a><time datetime="2022-03-16T02:47:00.000Z" title="发表于 2022-03-16 10:47:00">2022-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/02/LeetCode%E5%88%B7%E9%A1%8C%E7%AD%86%E8%A8%98(03.02-03.15)/" title="LeetCode刷題筆記(03.02-03.15)"><img src="https://cdn.jsdelivr.net/gh/lz37/images/img/29535589_84295672_p0_Archive%20%20%E9%87%8C%E4%B8%AA%E4%BA%BA%E5%AD%98%E6%A1%A3%E5%A4%84_%E8%BE%89%E7%8F%96%E7%AA%81%E5%9B%B4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode刷題筆記(03.02-03.15)"/></a><div class="content"><a class="title" href="/2022/03/02/LeetCode%E5%88%B7%E9%A1%8C%E7%AD%86%E8%A8%98(03.02-03.15)/" title="LeetCode刷題筆記(03.02-03.15)">LeetCode刷題筆記(03.02-03.15)</a><time datetime="2022-03-02T08:34:00.000Z" title="发表于 2022-03-02 16:34:00">2022-03-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 零泽</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>